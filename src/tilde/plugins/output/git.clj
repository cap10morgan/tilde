(ns tilde.plugins.output.git
  (:require [clojure.java.io :as io]
            [clojure.string :as str]
            [tilde.plugins.output :as output])
  (:import (java.io File)))

(defn- ignore-cfg->git-ignore
  [plugin output-dir {:keys [ignore] :as cfg}]
  [(-> cfg
       (assoc-in [(output/plugin-name plugin) :core :excludesFile]
                 (str/join "/"
                           [output-dir (-> plugin output/output-files :ignore)]))
       (dissoc :ignore))
   (str (str/join "\n" ignore) "\n")])

(defn- cfg->git-cfg
  ([_plugin _output-dir cfg]
   ;; top level generator doesn't need to return a new cfg
   [nil (cfg->git-cfg cfg nil)])
  ([cfg section]
   (str
    (reduce-kv
     (fn [output k v]
       (str output
            (if (map? v)
              (if section
                (str "[" section " \"" (name k) "\"]\n"
                     (cfg->git-cfg v nil)
                     "\n")
                (let [subsections (into {} (filter (fn [[_ v']] (map? v')) v))]
                  (str
                   (let [top-level (into {} (remove (fn [[k']]
                                                      (contains? subsections k'))
                                                    v))]
                     (when (seq top-level)
                       (str "[" (name k) "]\n"
                            (cfg->git-cfg top-level nil)
                            "\n")))
                   (cfg->git-cfg subsections (name k)))))
              (let [val (if (keyword? v) (name v) v)]
                (keyword? v) (str "\t" (name k) " = " val "\n")))))
     "" cfg))))

(defrecord OutputPluginGit
  [name files generators preambles]
  output/OutputPlugin
  (plugin-name [this] (.-name this))
  (output-files [this] (.-files this))
  (output-generators [this] (.-generators this))
  (output-preambles [this] (.-preambles this))
  (latest-output-update [this output-dir]
    (println "output plugin" (str "'" (output/plugin-name this) "'")
             "getting latest update timestamp of all outputs")
    (let [xf (comp
              (map #(conj [output-dir] %))
              (map #(str/join "/" %))
              (map io/file)
              (map File/.lastModified))]
      (transduce xf max 0 (->> this output/output-files vals))))
  (write! [this output-dir cfg]
    (let [top-level-output  (output/plugin-name this)
          potential-outputs (conj (vec (keys cfg)) top-level-output)
          output-gens       (select-keys (output/output-generators this)
                                         potential-outputs)
          active-outputs    (-> output-gens
                                keys
                                (->> (remove #(= % top-level-output)))
                                vec
                                (conj top-level-output))
          output-pres       (select-keys (output/output-preambles this)
                                         (conj potential-outputs ::all))
          output-contents   (loop [[k & ks] active-outputs
                                   cfg      cfg
                                   contents {}]
                              (let [preamble (or (get output-pres k)
                                                 (get output-pres ::all))
                                    _        (println "getting generator for" k)
                                    generate (get output-gens k)
                                    _        (println "got generator:" generate)
                                    [cfg out] (generate this output-dir cfg)
                                    _        (println "generator returned new cfg:"
                                                      (pr-str cfg))
                                    _        (println "generator returned output:"
                                                      (pr-str out))
                                    contents (assoc contents
                                               k (str (when preamble
                                                        (str preamble "\n"))
                                                      out))]
                                (if (seq ks)
                                  (recur ks cfg contents)
                                  contents)))]
      (doseq [[output-key filename] (output/output-files this)]
        (let [dest (str/join "/" [output-dir filename])]
          (io/make-parents dest)
          (spit dest (get output-contents output-key)))))))

(defn new
  []
  (map->OutputPluginGit
   {:name       :git
    :files      {:git    "git/config"
                 :ignore "git/ignore"}
    :generators {:git    cfg->git-cfg
                 :ignore ignore-cfg->git-ignore}
    :preambles  {::all "# This config generated by tilde; DO NOT MODIFY\n"}}))
